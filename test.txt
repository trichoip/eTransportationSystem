-notication 
-email 
-validate phone



- create sql server amazon
- deploy backend to amazon
- create my sql amazon
- install mysql
- config mysql spring boot
- deploy backend to docker
- deploy backend to docker to amazon
- xin viec




- neu la Double , Integer, Long ... thi se co gia tri defaul la null
- neu int , long , double ... thi se co gia tri default khac null


  // @Override
    // @Transactional
    // // lay ra entity 1 rui set entity 2 trong entity 1 thi bi error
    // // vd: account.setDrivingLicense -> error
    // // chi loi khi co @Transactional -> xoa @Transactional fixbug
    // public AccountInfoResponse findAccountById(Long id) {

    // Account account = accountRepository.findById(id)
    // .orElseThrow(() -> new IllegalArgumentException("Account is not found!"));

    // if (account.getDrivingLicense() == null) {
    // DrivingLicense drivingLicense = new DrivingLicense();
    // drivingLicense.setStatus(DrivingLicenseStatus.NOTYET);
    // account.setDrivingLicense(drivingLicense);
    // }
    // return modelMapper.map(account, AccountInfoResponse.class);
    // }

-cv
- nếu 1 class mà khong kế thừa từ ai thì hashcodeandequal sẽ so sánh tất cả các fiel trong class đó
-nếu 1 class mà có extend từ 1 class cha thì hashcodeandequal thì mặc định là @EqualsAndHashCode(callSuper = false) 
->có nghĩa là nó chỉ so sánh tất cả fiel trong class con chứ không so sanh gồm cả fiel class cha
- nếu muốn so sánh tất cả fiel gồm class cha và con thì set "callSuper = true" vd: @EqualsAndHashCode(callSuper = true)


- trong @onetomany one là father và many là child khi save father thì chỉ save father chứ không có save child , kể cả khi set father vào list child thì vẫn chỉ save father
-nếu muốn save father mà tự động save child thì phải có cascade = CascadeType.ALL trong father
- nếu đã có cascade = CascadeType.ALL trong father -> có 2 trường hợp đặc biệt
+nếu father có child mà child không có father thì khi save father thì vẫn save child nhưng fiel father_id trong child là null
+nếu father có child mà child có father thì khi save father thì trong db child có fiel father_id là id của father

  // forenkey(child) onetoone khong can optional = false
  // primekey(father) onetoone thi can optional = false de fech lazy hieu qua 
  luu y: fetch = FetchType.LAZY, optional = false  nếu query father xong mà có xử lý gọi child ra thì nếu father có child thì sẽ không báo lỗi còn nếu father mà không có child thì sẽ có error 

error: "like" ,"user"

@org.springdoc.api.annotations.ParameterObject Pageable pageable

// ManagementController => updateEmployee
     // ! trong ManyToOne của account nếu dùng modelmapper để map DepartmentDto sang Department
                // ! thì modelmapper chỉ mapper propertier của DepartmentDto sang Department
                // ! cho nên khi add thì nó tạo mới Department nên không có attach nên nó sẽ không thay đổi nội dung của Department
                // ! nếu mà update thì khi findbyid Department thì nó đang được attach, mà dùng modelmapper để map DepartmentDto sang Department thì nó sẽ mapper propertier của DepartmentDto sang Department
                // !  mà chỉ map propertier thì Department vẫn đang đang được attach thì khi save nó sẽ thay đổi luôn nội dung của cha (Department)
                // ! nếu muốn update chỉ thay đổi khóa phụ của cha thì có 3 cách:
                // ! cách 1 : trước khi mapper thì set cha null vì set cha null thì mapper sẽ tạo mới class cha nên không còn được attach
                // ! cách 2 : thay vì dùng DepartmentDto.class thì dùng Department.class trong accountdto vì mapper mà khác class thì nó mapper properties còn nếu cùng class entity thì nó truyền thằng class vào và không có map properties
                // ! cách 3 : dùng TypeMap (cách này giống cách 2 mà dùng TypeMap)


List<?> là một danh sách không xác định kiểu (List of unknown type). 
Nó cho phép chứa các phần tử của bất kỳ kiểu dữ liệu nào,
 nhưng thông tin về kiểu cụ thể của các phần tử trong danh sách bị ẩn đi.
  Điều này đảm bảo tính linh hoạt,
   nhưng đồng thời giới hạn khả năng truy xuất các phần tử từ danh sách. 
   Ví dụ: List<?> có thể là List<String>, List<Integer>, hoặc bất kỳ loại List nào khác.

 List<?> không thể ép kiểu trực tiếp như này
List<String> stringList = (List<String>) myList; // Lỗi biên dịch

mà chỉ có thể
 List<?> myList = new ArrayList<>();
// ... Thêm các phần tử vào danh sách

Object element = myList.get(index);
if (element instanceof String) {
    String stringValue = (String) element; // Ép kiểu thành String
    // Sử dụng stringValue làm gì đó...
}





List<Object> là một danh sách chứa các phần tử có kiểu dữ liệu là Object. 
Object là một kiểu cơ sở mà tất cả các lớp khác đều kế thừa trong Java.
 Vì vậy, List<Object> có thể chứa các đối tượng của bất kỳ kiểu lớp nào. 
 Tuy nhiên, khi bạn truy xuất các phần tử từ danh sách List<Object>, 
 bạn cần ép kiểu (cast) chúng thành kiểu dữ liệu phù hợp để sử dụng.

Object có thể chứa list, class,...

Object cast được 

 Object attendance(String type, Long schedulesId, Authentication authentication); 
 return new ResponseEntity<>("You already Check In today at: " + timeKeeping.getDate() + " " + timeKeeping.getTimein(),HttpStatus.BAD_REQUEST);

Object attendance = timeKeepingService.attendance(type, schedulesId, authentication);
ResponseEntity<?> responseEntity = (ResponseEntity<?>) attendance;





