-notication 
-email 
-validate phone



- create sql server amazon
- deploy backend to amazon
- create my sql amazon
- install mysql
- config mysql spring boot
- deploy backend to docker
- deploy backend to docker to amazon
- xin viec




- neu la Double , Integer, Long ... thi se co gia tri defaul la null
- neu int , long , double ... thi se co gia tri default khac null


  // @Override
    // @Transactional
    // // lay ra entity 1 rui set entity 2 trong entity 1 thi bi error
    // // vd: account.setDrivingLicense -> error
    // // chi loi khi co @Transactional -> xoa @Transactional fixbug
    // public AccountInfoResponse findAccountById(Long id) {

    // Account account = accountRepository.findById(id)
    // .orElseThrow(() -> new IllegalArgumentException("Account is not found!"));

    // if (account.getDrivingLicense() == null) {
    // DrivingLicense drivingLicense = new DrivingLicense();
    // drivingLicense.setStatus(DrivingLicenseStatus.NOTYET);
    // account.setDrivingLicense(drivingLicense);
    // }
    // return modelMapper.map(account, AccountInfoResponse.class);
    // }

-cv
- nếu 1 class mà khong kế thừa từ ai thì hashcodeandequal sẽ so sánh tất cả các fiel trong class đó
-nếu 1 class mà có extend từ 1 class cha thì hashcodeandequal thì mặc định là @EqualsAndHashCode(callSuper = false) 
->có nghĩa là nó chỉ so sánh tất cả fiel trong class con chứ không so sanh gồm cả fiel class cha
- nếu muốn so sánh tất cả fiel gồm class cha và con thì set "callSuper = true" vd: @EqualsAndHashCode(callSuper = true)


- trong @onetomany one là father và many là child khi save father thì chỉ save father chứ không có save child , kể cả khi set father vào list child thì vẫn chỉ save father
-nếu muốn save father mà tự động save child thì phải có cascade = CascadeType.ALL trong father
- nếu đã có cascade = CascadeType.ALL trong father -> có 2 trường hợp đặc biệt
+nếu father có child mà child không có father thì khi save father thì vẫn save child nhưng fiel father_id trong child là null
+nếu father có child mà child có father thì khi save father thì trong db child có fiel father_id là id của father

  // forenkey(child) onetoone khong can optional = false
  // primekey(father) onetoone thi can optional = false de fech lazy hieu qua 
  luu y: fetch = FetchType.LAZY, optional = false  nếu query father xong mà có xử lý gọi child ra thì nếu father có child thì sẽ không báo lỗi còn nếu father mà không có child thì sẽ có error 

error: "like" ,"user"

@org.springdoc.api.annotations.ParameterObject Pageable pageable

// ManagementController => updateEmployee
     // ! trong ManyToOne của account nếu dùng modelmapper để map DepartmentDto sang Department
                // ! thì modelmapper chỉ mapper propertier của DepartmentDto sang Department
                // ! cho nên khi add thì nó tạo mới Department nên không có attach nên nó sẽ không thay đổi nội dung của Department
                // ! nếu mà update thì khi findbyid Department thì nó đang được attach, mà dùng modelmapper để map DepartmentDto sang Department thì nó sẽ mapper propertier của DepartmentDto sang Department
                // !  mà chỉ map propertier thì Department vẫn đang đang được attach thì khi save nó sẽ thay đổi luôn nội dung của cha (Department)
                // ! nếu muốn update chỉ thay đổi khóa phụ của cha thì có 3 cách:
                // ! cách 1 : trước khi mapper thì set cha null vì set cha null thì mapper sẽ tạo mới class cha nên không còn được attach
                // ! cách 2 : thay vì dùng DepartmentDto.class thì dùng Department.class trong accountdto vì mapper mà khác class thì nó mapper properties còn nếu cùng class entity thì nó truyền thằng class vào và không có map properties
                // ! cách 3 : dùng TypeMap (cách này giống cách 2 mà dùng TypeMap)